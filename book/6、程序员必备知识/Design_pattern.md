

--------

1、继承：class，提取公共模块，减少冗余

2、封装：public、protected、private

减少耦合、利于数据与接口的权限管理、 es6目前不支持 （约定_）

3、多态

同一个接口，不同表现；需要结合java等语言的接口、重写、重载等功能



jq是一个class

------

为何要面向对象：

1、程序执行：顺序、判断、循环 => 结构化

2、面向对象 => 数据结构化

3、对计算机，结构化的才是最简单的

4、编程应该 简单 & 抽象

------

UML统一建模语言

UML类图：属性、方法

关系：泛化（继承）和关联（引用）

```
public、protected、private ：+ # -

实心箭头（引用） 空心箭头（继承）
```

----

《UNIX/LINUX设计模式》

1、小即而美

2、让每个程序只做一件事

3、快速建立模型

4、舍弃高效率而取可移植性

5、采取纯文本来存储数据

6、充分利用软件的杠杆效应（软件复用）

7、使用shell脚本来提高杠杆效应和可移植性

8、避免强制的用户界面

9、让每个程序都成为过滤器



小准则-

允许用户定制环境

尽量使用操作系统内核小而轻量化

使用小写字母并尽量简短

沉默是金

各部分之和大于整体

寻求90%的解决方案（2/8定律）



-------

<b>从设计到模式</b>

<b>设计</b>原则：<b>SO</b>LID

<b>S</b>：单页职责原则

一个程序只做好一件事

 如果功能过于复杂就拆分开，每个部分保持独立

<b>O</b>：开放封闭原则

对扩展开放，对修改封闭

增加需求时，扩展新代码，而非修改已有代码

是软件设计的终极目标

L：李氏置换原则

子类能覆盖父类

父类能出现的地方子类能出现

js中使用较少（弱类型&继承使用较少）

I：接口独立原则

保持<b>接口</b>的单一独立，避免出现“胖接口”

js 中没有接口（ts除外），使用较少

类似于单一职责原则，这里更关注接口

D：依赖导致原则

面向<b>接口</b>编程，依赖于抽象而不依赖于具体

使用方只关注接口而不关注具体类的实现

js中使用较少（没有接口&弱类型）

-------

promise 中的S O :

1、每个then只做一件事

2、如果有新增需求，扩展then

-------

<b>模式</b>23种

1、创建型

- 工厂模式：工厂方法模式、抽象工厂模式、建造者模式

  介绍：将new操作单独封装，遇到new时，就要考虑是否使用工厂模式

  场景：

  1、$('div')（工厂模式） 的区别new $("div")

  - 1、书写麻烦，jq链式操作将会成为噩梦

  - 2、一旦jq名字变化，将是灾难性的

  React.createElement操作new Vnode

  3、vue异步组件

  设计验证验证：
  1、构造函数和创建者分离

  2、符合开放封闭原则

- 单例模式

介绍：系统中被唯一使用，一个类只有一个实例

场景：jq的$、vuex和redux中的store、登录逻辑（购物车）

设计原则验证：

符合单一职责原则，只实例化唯一的对象

没有具体开放封闭原则，但是绝对不违反开放封闭原则

- 原型模式

2、结构型

- 适配器模式

  介绍：旧接口格式和使用者不兼容，中间加一个适配转换接口

  场景：旧接口的封装、vue computed

- 装饰器模式

  介绍：为对象添加新功能，不改变其原有结构与功能

  事例：手机壳

  场景：es7装饰器，core-decorators

  设计原则验证：

  - 1、将现有对象和装饰器进行分离，两者独立存在
  - 2、符合开放封闭原则

- 代理模式

  介绍：使用者无权访问目标对象，中间加代理，通过代理做授权和控制

  事例：科学上网（访问github），明星经纪人

  场景 : 网页事件代理、JQ $.proxy、es6 Proxy

  设计原则验证：

  - 代理类和目标类分离，隔离开目标类和使用者
  - 符合开放封闭原则

  ----

  代理模式vs适配器模式

  适配器模式：提供一个不同的接口

  代理模式：提供一模一样的接口

  代理模式vs装饰器模式

  装饰器模式：扩展功能，原有功能不变且可直接使用

  代理模式：显示原有功能，但是经过限制或者阉割之后的

- 外观模式

  介绍：为子系统中的一组接口提供了一个高层接口；使用者使用这个高层接口

  事例：

  场景：fn传参兼容各种长度的传参

  设计原则验证：

  - 不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用

- 桥接模式

- 组合模式

- 享元模式

3、行为型

- 策略模式

- <b>迭代器模式</b>

  介绍：顺序遍历(有序)集合；使用者无需知道集合的内部结构（封装）

  事例：jq $each、es6 Iterator

  场景：有序数据集合：Array、Map 、Set、String、TypedArray 、arguments、NodeList

  [Symbol.iterator]属性运行Array.prototype[Symbol.iterator]测试；属性值是函数，执行函数返回一个迭代器；这个迭代器就有next方法可执行顺序迭代子元素；

  需要有一个统一的遍历接口来遍历所有数据类型（object不是有序的数据集合，可用map代替）

  <b>Generator</b>

  设计原则验证：

  - 迭代器对象和目标分离
  - 迭代器将使用者和目标短息隔离开
  - 符合开放封闭原则

- 模板方法模式

- 责任链模式（职责链模式）

- <b>观察者模式</b>

  介绍：发布&订阅，一对n

  事例：订报纸、订牛奶

  场景：网页事件绑定、promise状态变化触发绑定事件、jq callbacks、

  nodejs中：nodejs自定义事件EventEmitter；处理http请求、多进程通信；（nodejs处理流，用on data、on end）

  vue和react组件生命周期触发

  vue watch

  设计原则验证：

  - 主题和观察者分离，不是主动触发而是被动监听，两者解耦
  - 符合开放封闭原则

- 命令模式 

- 备忘录模式

- 中介者模式

- 状态模式

  介绍：一个对象有状态变化；每次状态变化都会触发一个逻辑；不能总是用if...else控制

  事例：交通信号红绿灯

  场景：有限状态机、promise状态变化的监听

  lib：javascript-state-machine

- 解释器模式

- 访问者模式

-----

优先级划分依据：

- 不常用

- 对应不到经典的应用场景：

行为型：

- 策略模式

  概念：不同策略分开处理；避免出现大量的if...else或者switch...case

- 模板方法模式

  概念：一个方法，统一调用其他方法

- 职责链模式

  概念：一步操作可能分为多个职责角色来完成

  场景：js链式操作

  设计原则验证：

  - 发起者于各个处理者进行隔离
  - 符合开放封闭原则

- 命令模式 

  概念：执行命令时，发布者和执行者分开；中间加入命令对象，作为中转站

  场景：网页富文本编辑器

  设计原则验证：

  - 命令对象执行对象分开，解耦
  - 符合开放封闭原则

- 备忘录模式

  概念：随时记录一个对象的状态变化；随时可以恢复之前的某个状态（如：撤销功能）

  设计原则验证：

  - 状态对象于使用者分开、解耦
  - 符合开放封闭原则

- 中介者模式

  概念：对象于对象之前访问，通过中介者

  设计原则验证：

  - 各个关联对象通过中介者隔离
  - 符合开放封闭原则

- 解释器模式

  概念：描述语言语法如何定义，如何解释和编译

- 访问者模式

  概念：将数据操作和数据结构进行分离

2、结构型

- 桥接模式

  概念：用于把抽象化与实际化解耦；使得两者可以独立变化

- 组合模式

  概念：生成树形结构，表示“整体-部分”关系；让整体和部分具有一致的操作方式与数据结构

  虚拟dom中的vnode

- 享元模式

  概念:共享内存（主要考虑内存，而非效率）；相同数据，共享使用

  场景：把事件绑定至上层容器，代替子容器绑定

  设计原则验证：

  - 将相同的部分抽象出来

1、创建型

- 原型模式

  概念：clone自己，生成一个新的对象；

  Object.create() 

------

js设计停车场

https://github.com/jeremyjone/design-pattern-js

----

综合应用：

jq做个模拟购物车的事例

功能：显示购物列表、加入购物车、从购物车删除

工厂模式 单例模式

装饰器模式 观察者模式

状态模式 模板方法模式 代理模式





