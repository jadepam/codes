# 《Web 前端性能优化》读书笔记（Mini Book）

## **第一篇 前端性能优化概述**

### **第 1 章 什么是性能优化**

**性能起因**

市场竞争驱动，用户对加载速度、交互流畅度的要求提升。

性能影响用户留存（加载超 3s 流失 53% 移动端用户）、转化率（加载快 100ms 转化率提升 1.55%）和口碑传播。

**RAIL 性能模型**

**响应（Response）**：用户操作需在 100ms 内反馈，避免阻塞主线程。

**动画（Animation）**：目标 60fps，每帧耗时≤16ms，优先使用 CSS 动画而非 JavaScript。

**空闲（Idle）**：利用空闲时间处理非关键任务，任务分组≤50ms。

**加载（Load）**：首屏加载≤1s，关键渲染路径优先加载，非关键资源延迟加载。

**优化步骤**

**测量**：使用 Lighthouse、Chrome Performance 工具分析性能指标（FCP、TTI 等）。

**分析**：拆解页面生命周期，定位瓶颈（如网络延迟、渲染阻塞）。

**实施**：针对性优化（如资源压缩、缓存策略、代码优化）。

### **第 2 章 前端页面的生命周期**

**核心流程**

**网络请求**：DNS 解析→TCP 三次握手→HTTP 请求，减少 DNS 查询和 TCP 连接耗时。

**渲染流程**：

DOM 树与 CSSOM 树构建→渲染树生成（排除不可见节点）→布局（计算盒模型）→绘制（像素渲染）→合成（多图层合并）。

**关键路径优化**：减少阻塞渲染的资源（如异步加载 JS、内联关键 CSS）。

**浏览器机制**

多进程架构（主进程、渲染进程、GPU 进程、网络进程、插件进程）避免阻塞。

缓存策略：强缓存（Cache-Control）与协商缓存（ETag/Last-Modified）结合使用。

## **第二篇 典型模块的性能优化**

### **第 3 章 图像优化**

**基础策略**

**格式选择**：

矢量图（SVG）：图标、Logo，缩放无损，文件小。

位图：照片用 WebP（压缩比高，需兼容处理），小图标用 PNG-8，动画用视频替代 GIF。

**分辨率适配**：使用`srcset`和`picture`标签提供多分辨率图片。

**压缩与处理**：去除元数据，使用渐进式 JPEG、雪碧图合并小图标。

**实践建议**

避免 Base64 编码大图片，优先使用 CDN 加速静态资源。

### **第 4 章 加载优化**

**延迟加载**

**图片 / 视频**：使用`loading="lazy"`、Intersection Observer API，首屏外资源延迟加载。

**策略**：占位图（LQIP/SQIP）、预加载关键资源（`<link rel="preload">`）。

**优先级控制**

预连接（`<link rel="preconnect">`）加速 DNS 解析和 TCP 连接。

预提取（`<link rel="prefetch">`）利用空闲带宽加载后续可能用到的资源。

### **第 5 章 书写高性能代码**

**数据与流程**

**作用域**：缓存全局变量为局部变量，减少作用域链查找。

**循环与条件**：避免`for-in`循环，优先使用`for-of`；复杂条件用策略模式或对象映射替代多层`if-else`。

**性能细节**

字符串拼接用`+=`或数组`join()`，避免`eval()`和多重求值。

动画用`requestAnimationFrame`，避免频繁 DOM 操作触发重排 / 重绘。

### **第 6 章 构建优化**

**压缩与合并**

HTML/CSS/JS 去空格、注释，JS 混淆保护代码。

代码拆分：公共库（如 React）单独打包，路由分块加载（`import()`）。

**Webpack 优化**

使用 DllPlugin 预打包第三方库，Happypack 开启多进程编译，`Tree-shaking`移除未使用代码。

### **第 7 章 渲染优化**

**关键阶段**

**JavaScript**：Web Worker 处理计算密集任务，事件节流 / 防抖（`debounce`/`throttle`）。

**样式与布局**：避免高频修改布局属性（如`offsetTop`），批量修改样式或使用类名切换。

**合成层**：提升动画元素至独立图层（`will-change: transform`），减少重绘区域。

**工具检测**

Chrome Rendering 工具监控重绘区域，Layers 面板分析图层性能。

### **第 8 章 服务器端渲染（SSR）**

**核心优势**

首屏渲染更快，提升 SEO（搜索引擎可抓取动态内容）。

同构应用：一套代码同时运行于服务端和客户端，数据预取减少客户端压力。

**框架实践**

Vue/React 中使用`renderToString`生成 HTML，注意生命周期差异（如服务端无`mounted`）。

数据注水 / 脱水：服务端渲染数据传递给客户端，避免重复请求。

### **第 9 章 数据存储**

**存储方案对比**



| 方式            | 容量     | 持久性     | 类型       | 适用场景     |
| ------------- | ------ | ------- | -------- | -------- |
| Cookie        | 4KB    | 会话 / 持久 | 字符串      | 登录态、会话标识 |
| Local Storage | 5-10MB | 持久      | 字符串      | 本地化配置    |
| IndexedDB     | 250MB+ | 持久      | 对象 / 二进制 | 大量数据存储   |

**最佳实践**
IndexedDB 异步操作避免阻塞主线程，Web SQL 逐步被废弃，优先使用 IndexedDB。

### **第 10 章 缓存技术**

**HTTP 缓存**

**强缓存**：`Cache-Control: max-age=31536000`，减少服务器交互。

**协商缓存**：`ETag`优先于`Last-Modified`，精准判断资源变化。

**进阶缓存**

Service Worker：拦截请求，实现离线缓存（需 HTTPS 支持）。

CDN 缓存：静态资源（JS/CSS/ 图片）分布式存储，就近访问降低延迟。

## **第三篇 前端性能检测实践**

### **第 11 章 性能检测**

**核心工具**

**Lighthouse**：自动化检测性能、可访问性、SEO，生成优化建议（如移除阻塞资源、启用 HTTP2）。

**Chrome Performance**：记录页面生命周期，分析主线程任务、内存、网络耗时，定位重排 / 重绘高频区域。

**关键指标**

**FCP（首次内容绘制）**：≤1s 为优，关注首屏资源加载顺序。

**TTI（可交互时间）**：减少主线程阻塞，优先加载关键交互逻辑。

## **快速查阅索引**



| 优化方向 | 核心技术 / 工具                        | 对应章节   |
| ---- | -------------------------------- | ------ |
| 图像优化 | WebP、SVG、雪碧图、`srcset`            | 第 3 章  |
| 加载优化 | 延迟加载、预加载、优先级控制                   | 第 4 章  |
| 代码优化 | 作用域缓存、事件节流、Web Worker            | 第 5 章  |
| 构建优化 | Webpack 分包、Tree-shaking、压缩合并     | 第 6 章  |
| 渲染优化 | 合成层、重排避免、`requestAnimationFrame` | 第 7 章  |
| 缓存策略 | HTTP 缓存、Service Worker、CDN       | 第 10 章 |
| 性能检测 | Lighthouse、Performance 面板        | 第 11 章 |

**注**：读书笔记聚焦核心知识点，详细实践案例及代码示例请参考原书对应章节。