
[TOC]



# 1、二分查找
>对于包含n个元素的有序列表，用二分查找最多需要log2n步，而简单查找最多需要n步
* 算法是一组完成任务的指令
* 算法的速度指的并非时间，而是操作数的增速。
* 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
* 算法的运行时间用大O表示法表示。
* O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快

# 2、选择排序

>数组和链表

需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存
储多项数据时，有两种基本方式——数组和链表

数组：数组意味着所有待办事项在内存中都是相连的
链表：链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起

单链表、双链表

常见数组和链表操作的运行时间

操作| 数组 | 链表 |
- | :-: | :-: | 
读取（查找） | O(1) | O(N) | 
插入 | O(N)| O(1)| 
删除 |O(N)| O(1) | 


>选择排序

选择排序是一种灵巧的算法，但其速度不是很快。O(N * N)
N+(N-1)+(N-2)+...+1 ~ N*N/2

# 3、递归

* 递归指的是调用自己的函数。
* 每个递归函数都有两个条件：基线条件和递归条件。
* 栈有两种操作：压入和弹出。
* 所有函数调用都进入调用栈。
* 调用栈可能很长，这将占用大量的内存。

> 尾递归


    通过参数传递结果，达到不压栈的目的

如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归

# 4、D&C算法——快速排序

欧几里德算法:计算两个正整数a，b的最大公约数

D&C的工作原理：

(1) 找出简单的基线条件;

(2) 确定如何缩小问题的规模，使其符合基线条件;

> 函数式编程

函数式编程语言里没有 for/next 循环，因为这些逻辑意味着有状态的改变。相替代的是，这种循环逻辑在函数式编程语言里是通过递归、把函数当成参数传递的方式实现的。


> 快速排序

快速排序是最快的排序算法之一，也
是D&C典范

(1) 选择基准值。

(2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。

(3) 对这两个子数组进行快速排序

平均时间，

平均运行时间O(n log n)

合并排序运行时间总是O(n log n)

* D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元
素的数组。
* 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。
* 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
* 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)
快得多


# 5、散列表

散列表：一种数据结构

散列函数：将输入映射为数字

* 模拟映射关系
* 防止重复
* 缓存/记住数据，以免服务器再通过处理来生成它们

操作| 散列表(平均情况)|散列表(最糟情况)|数组 | 链表 |
- | :-: | :-:| :-:| :-: | 
读取 |O(1)|O(N)| O(1) | O(N) | 
插入 |O(1)|O(N)| O(N)| O(1)| 
删除 |O(1)|O(N)|O(N)| O(1) | 

避免冲突：

* 较低的填装因子
* 良好的散列函数

填装因子:数组表包含的元素数/位置总数

* 你可以结合散列函数和数组来创建散列表。
* 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
* 散列表的查找、插入和删除速度都非常快。
* 散列表适合用于模拟映射关系。
* 一旦填装因子超过0.7，就该调整散列表的长度。
* 散列表可用于缓存数据（例如，在Web服务器上）。
* 散列表非常适合用于防止重复

# 6、广度优先搜索

解决最短路径问题的算法被称为广度优先搜索

> 队列

队列只支持两种操作： 入队和出队

队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last In
First Out， LIFO）的数据结构

> 图、树

图，由节点（人）和边组成

树是一种特殊的图，其中没有往后指的边（家谱）

* 广度优先搜索指出是否有从A到B的路径。
* 如果有，广度优先搜索将找出最短路径。
* 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来
解决问题。
* 有向图中的边为箭头，箭头的方向指定了关系的方向，例如， rama→adit表示rama欠adit钱。
* 无向图中的边不带箭头，其中的关系是双向的，例如， ross - rachel表示“ross与rachel约
会，而rachel也与ross约会”。
* 队列是先进先出（ FIFO）的。
* 栈是后进先出（ LIFO）的。
* 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必
须是队列。
* 对于检查过的人，务必不要再去检查，否则可能导致无限循环


# 7、狄克斯特拉算法

加权图——提高或降低某些边的权重

广度优先搜索：查找两点之间的最短路径

狄克斯特拉算法：找出的是总权重最小的路径

> 权重

带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（ unweighted graph）

在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图（ directed acyclic
graph， DAG）

如果有负权边，就不能使用狄克斯特拉算法

> 贝尔曼——福德算法

* 广度优先搜索用于在非加权图中查找最短路径。
* 狄克斯特拉算法用于在加权图中查找最短路径。
* 仅当权重为正时狄克斯特拉算法才管用。
* 如果图中包含负权边，请使用贝尔曼-福德算法

# 8、贪婪算法

最短路径问题(广度优先、狄克斯特拉)



# 9、动态规划

动态规划先解决子问题，再逐步解决大问题

* 需要在给定约束条件下优化某种指标时，动态规划很有用。
* 问题可分解为离散子问题时，可使用动态规划来解决。
* 每种动态规划解决方案都涉及网格。
* 单元格中的值通常就是你要优化的值。
* 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
* 没有放之四海皆准的计算动态规划解决方案的公式

# 10、K最近邻算法

> 反向索引

> 傅里叶变换

> 并行算法

> SHA 算法

 最安全的密码散列函数是bcrypt
 
> 线性规划

